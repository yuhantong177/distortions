"""Utility to register a segmented SEM/CL/BSE image onto an EBSD reference.

This module simply wraps the two steps available in :mod:`align` and
:mod:`distord` so that they can be called from a single command.  The script
is intentionally lightweight – it only glues the existing building blocks
together – therefore the heavy lifting is still performed by the original
code.  The goal is to make it easier to reuse the repository when one wants
to warp any segmented electron image (SEM‑CL, SE, BSE, …) so that it matches
an EBSD map.

Example
-------

```
python -m register_modal_image \
    --seg-image ../data/AM718/segment/AM718_segment.png \
    --ebsd-image ../data/AM718/ebsd/AM718_ebsd.jpg \
    --ang-file ../data/AM718/ang/AM718/AM718.ang \
    --config ../conf/AM718.align.conf \
    --output-dir ../data/AM718/out_demo \
    --xp-id 0 \
    --mesh-step 65 --mesh-std 5 --num-sampling 200 --polynom 3
```

The command above creates all the files produced by ``align.py`` and
``distord.py`` in ``../data/AM718/out_demo`` while also exposing the
intermediate aligned segmentation in ``../data/AM718/out_demo/aligned``.
"""

from __future__ import annotations

import argparse
import os
from types import SimpleNamespace

from src.align import __main__ as run_align
from src.distord import __main__ as run_distord


def _ensure_dir(path: str) -> str:
    """Create *path* if it does not already exists and return it."""

    os.makedirs(path, exist_ok=True)
    return path


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Run the align + distortion pipeline in a single command",
    )
    parser.add_argument(
        "--seg-image",
        required=True,
        help="Path to the segmented SEM/CL/BSE image that must be warped",
    )
    parser.add_argument(
        "--ebsd-image",
        required=True,
        help="Reference EBSD speckle image used as the alignment target",
    )
    parser.add_argument(
        "--ang-file",
        required=True,
        help="ANG file associated with the EBSD dataset",
    )
    parser.add_argument(
        "--config",
        required=True,
        help="Configuration JSON describing the grid-search ranges for align",
    )
    parser.add_argument(
        "--output-dir",
        required=True,
        help="Directory where every intermediate and final result is stored",
    )
    parser.add_argument(
        "--align-dir",
        help=(
            "Optional directory to store the aligned segmentation.  By"
            " default a sub-folder named 'aligned' is created inside"
            " --output-dir."
        ),
    )
    parser.add_argument(
        "--xp-id",
        type=int,
        default=0,
        help="Identifier used in the file names produced by the pipeline",
    )
    parser.add_argument(
        "--mesh-step",
        type=float,
        default=65,
        help="Distance between two neighbouring control points (pixels)",
    )
    parser.add_argument(
        "--mesh-std",
        type=float,
        default=5,
        help="Standard deviation (pixels) explored by CMA-ES",
    )
    parser.add_argument(
        "--num-sampling",
        type=int,
        default=2500,
        help="Number of meshes sampled by CMA-ES",
    )
    parser.add_argument(
        "--polynom",
        type=int,
        default=3,
        help="Degree of the polynomial distortion",
    )
    parser.add_argument(
        "--phase-name",
        default="Prec",
        help="Phase name stored in the generated ANG file",
    )
    parser.add_argument(
        "--phase-formula",
        default="NiAl",
        help="Phase formula stored in the generated ANG file",
    )
    parser.add_argument(
        "--seed",
        type=int,
        default=None,
        help="Random seed forwarded to the CMA-ES optimiser",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()

    output_dir = _ensure_dir(args.output_dir)
    align_dir = _ensure_dir(args.align_dir or os.path.join(output_dir, "aligned"))

    # 1) Global alignment (rotation + translation)
    align_args = SimpleNamespace(
        seg_ref_path=args.seg_image,
        ebsd_ref_path=args.ebsd_image,
        conf_path=args.config,
        align_dir=align_dir,
        out_dir=output_dir,
        id_xp=args.xp_id,
    )
    best_score, _, _ = run_align(align_args)
    print(f"[register_modal_image] Best alignment score: {best_score:.4f}")

    # Path generated by align.py (segment.align.<xp-id>.png)
    aligned_segment_path = os.path.join(
        align_dir, f"segment.align.{args.xp_id}.png"
    )

    # 2) Non-linear distortion so that the EBSD speckle matches the SEM image
    distord_args = SimpleNamespace(
        seg_ref_path=aligned_segment_path,
        ebsd_ref_path=args.ebsd_image,
        ang_ref_path=args.ang_file,
        out_dir=output_dir,
        mesh_step=args.mesh_step,
        mesh_std=args.mesh_std,
        num_sampling=args.num_sampling,
        polynom=args.polynom,
        image_magic=False,
        phase_name=args.phase_name,
        phase_formula=args.phase_formula,
        id_xp=args.xp_id,
        seed=args.seed,
    )

    best_distord_score, _, _, _ = run_distord(distord_args)
    print(
        "[register_modal_image] Final distortion score: "
        f"{best_distord_score:.4f}"
    )


if __name__ == "__main__":
    main()

